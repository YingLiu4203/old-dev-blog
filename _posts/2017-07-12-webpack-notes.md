---
layout: post
title: Webpack notes
categories:
- Development
tags:
- FrontEnd
---

This is a notes based on the official [Webpack document]( https://webpack.js.org/) and the excellent book [SurviveJs Webpack](https://survivejs.com/webpack/).

# 1. Introduction
Webpack is a module bundler. It starts from an entry point and build all dependencies into a bundle or, when define split points, a small number of bundles. A module can be specified as ES2015 `import`, Node.js `require()`. Through loaders, a module can be specified using css/sass/less `@import` statement or a html url. 

Webpack only understands JavaScript files but treat every source file (.css, .html, .scss, .jpg, etc) as a module that is transformed by a corresponding loader on a per-file basis. Loaders are specified in `module.rules`.  Loaders can be chained in a bottom to top and right to left order. 

Plugins intercept runtime events and perform actions and custom functionality on chunks of bundled modules at different stages of the buildling process. Webpack comes with some built-in plugins. A webpack plugin is a JavaScript function whose `apply` property is called by the webpack compiler. 

Webpack is configuration driven and its configuration file is a a standard Node.js module. Webpack resolves module and loader using file type, file path and wheren it was imported/used in a project. Webpack let you control how to treat different assets such as inline separate files or put it into its scope.

As the webpack compiler resolves and builds an application, it keeps module dependency data as the "Manifest". After every module has been evaluated, webpack creates output that includes a bootstrap script and the manifiest. The manifest can be generated as a separate file. 

Hot Module Replacement(HMR) reloads updated modules without a full reload. `webpack-dev-server` uses in-memory compilation and provides an easy to use development server with fast live reloading.

Webpack supports code spliting and dynamic loading. It can inject a hash to file name. 

# 2. The Basic Development Process
For a basic build, you need to config the `entry` and `output`. 

The value of the `entry` could be a folder or a filename. If it is a folder, the default `index.js` will be used as the entry file. 

All output related paths are resolved against the `output.path` field. By default, the file specified by `output.filename` is the bundle file generated by putting all JS files together. All JS modules are put into an array of modules in the bundle file. The entry module is exported from the bundle file. 

You can use placeholders such as `[name]`, `[id]`, `[chunkhash]`, or `[hash]` in the output filename. 

The [`html-webpack-plugin`](https://github.com/jantimon/html-webpack-plugin) helps to create an HTML file to serve the generated JS bundle file. It can sync with the generated bundle file when a hash is used in filename. 

Using `webpack --watch` to rebuild when there is a file change. `webpack-dev-server` (WDS) goes future in that it stores results in memory. It support Hot Module Replacement (HMR) to patch the browser without a full refresh. HMR requires client-side code to work with WDS interfaces. There are plugins to write emitted files to the file system. WDS can be configured in the `devServer` section using parameters such as `historyApiFallback`, `stats`, `host`, `port` and the `aggregateTimeout` and `poll` of the `watchOptions`. 

Alternatively, you can use Express server and a middleware such as [`webpack-dev-middleware`](https://github.com/glenjamin/webpack-hot-middleware) to serve the output. 

The `friendly-errors-webpack-plugin` gives better status report. `eslint-loader` lints JS code. 